{"version":3,"sources":["util.js","App.js","index.js"],"names":["getOptions","x","y","maze","visited","options","cell","rows","length","cols","push","App","useState","gameId","setGameId","status","setStatus","size","setSize","cheatMode","setCheatMode","userPosition","setUserPosition","useMemo","totalCells","unvisited","i","j","currentCell","Math","floor","random","path","pot","neighbors","l","next","pop","generateMaze","solution","s","Set","solutionPath","startX","startY","endX","endY","currentX","currentY","solve","forEach","add","String","useEffect","lastRowIndex","lastColIndex","makeClassName","arr","has","join","handleUpdateSettings","Number","document","querySelector","value","className","onKeyDown","e","preventDefault","key","code","tabIndex","htmlFor","type","name","min","max","defaultValue","onClick","onChange","target","checked","id","map","row","rootElement","getElementById","ReactDOM","render"],"mappings":"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","file":"static/js/main.b611c2b6.chunk.js","sourcesContent":["/**\n *\n * @param {number} x - width of maze\n * @param {number} y  - height of maze\n * Cell value: maze[i][j][n] is 0 (cannot go thru / has wall) or 1 (can go thru / no wall)\n * n == 0: north wall, n == 1: east wall\n * n == 2: south wall, n == 3: west wall\n *\n */\nexport function generateMaze(x, y) {\n  // Establish variables and starting grid\n  const totalCells = x * y;\n  const maze = [];\n  const unvisited = [];\n  for (let i = 0; i < y; i++) {\n    maze[i] = [];\n    unvisited[i] = [];\n    for (let j = 0; j < x; j++) {\n      maze[i][j] = [0, 0, 0, 0];\n      unvisited[i][j] = true;\n    }\n  }\n\n  // Set a random position to start from\n  let currentCell = [\n    Math.floor(Math.random() * y),\n    Math.floor(Math.random() * x)\n  ];\n  const path = [currentCell];\n  unvisited[currentCell[0]][currentCell[1]] = false;\n  let visited = 1;\n\n  // Loop through all available cell positions\n  while (visited < totalCells) {\n    // Determine neighboring cells\n    const pot = [\n      [currentCell[0] - 1, currentCell[1], 0, 2],\n      [currentCell[0], currentCell[1] + 1, 1, 3],\n      [currentCell[0] + 1, currentCell[1], 2, 0],\n      [currentCell[0], currentCell[1] - 1, 3, 1]\n    ];\n    const neighbors = [];\n\n    // Determine if each neighboring cell is in game grid, and whether it has already been checked\n    for (let l = 0; l < 4; l++) {\n      if (\n        pot[l][0] > -1 &&\n        pot[l][0] < y &&\n        pot[l][1] > -1 &&\n        pot[l][1] < x &&\n        unvisited[pot[l][0]][pot[l][1]]\n      ) {\n        neighbors.push(pot[l]);\n      }\n    }\n\n    // If at least one active neighboring cell has been found\n    if (neighbors.length) {\n      // Choose one of the neighbors at random\n      const next = neighbors[Math.floor(Math.random() * neighbors.length)];\n\n      // Remove the wall between the current cell and the chosen neighboring cell\n      maze[currentCell[0]][currentCell[1]][next[2]] = 1;\n      maze[next[0]][next[1]][next[3]] = 1;\n\n      // Mark the neighbor as visited, and set it as the current cell\n      unvisited[next[0]][next[1]] = false;\n      visited++;\n      currentCell = [next[0], next[1]];\n      path.push(currentCell);\n    }\n    // Otherwise go back up a step and keep going\n    else {\n      currentCell = path.pop();\n    }\n  }\n  return maze;\n}\n\nexport function solve(\n  maze,\n  startX = 0,\n  startY = 0,\n  endX = maze.length - 1,\n  endY = maze[0].length - 1\n) {\n  const visited = [];\n  // Mark all cells as unvisited:\n  for (let x = 0; x < maze.length; x++) {\n    visited[x] = [];\n    for (let y = 0; y < maze[x].length; y++) {\n      visited[x][y] = false;\n    }\n  }\n\n  const solution = [];\n  let currentX = startX;\n  let currentY = startY;\n  let options = [];\n\n  while (currentX !== endX || currentY !== endY) {\n    visited[currentX][currentY] = true;\n    options = getOptions(currentX, currentY, maze, visited);\n\n    if (options.length === 0) {\n      const [newX, newY] = solution.pop();\n      currentX = newX;\n      currentY = newY;\n    } else {\n      solution.push([currentX, currentY]);\n      const [newX, newY] = options[0];\n      currentX = newX;\n      currentY = newY;\n    }\n  }\n\n  solution.push([currentX, currentY]);\n\n  return solution;\n}\n\n/*\n * Gets all of the cells we can possibly go to next.\n */\nfunction getOptions(x, y, maze, visited) {\n  const options = [];\n  const cell = maze[x][y];\n  const rows = maze.length;\n  const cols = maze[0].length;\n\n  // can go south\n  if (x + 1 < rows && !visited[x + 1][y] && cell[2] === 1) {\n    options.push([x + 1, y]);\n  }\n\n  // can go east\n  if (y + 1 < cols && !visited[x][y + 1] && cell[1] === 1) {\n    options.push([x, y + 1]);\n  }\n\n  // can go west\n  if (y - 1 >= 0 && !visited[x][y - 1] && cell[3] === 1) {\n    options.push([x, y - 1]);\n  }\n\n  // can go north\n  if (x - 1 >= 0 && !visited[x - 1][y] && cell[0] === 1) {\n    options.push([x - 1, y]);\n  }\n\n  return options;\n}\n","import { useState, useMemo, useEffect } from \"react\";\nimport { generateMaze, solve } from \"./util\";\nimport \"./styles.scss\";\n\nexport default function App() {\n  const [gameId, setGameId] = useState(1);\n  const [status, setStatus] = useState(\"playing\");\n\n  const [size, setSize] = useState(10);\n  const [cheatMode, setCheatMode] = useState(false);\n\n  const [userPosition, setUserPosition] = useState([0, 0]);\n\n  const maze = useMemo(() => generateMaze(size, size), [size, gameId]);\n  const solution = useMemo(() => {\n    const s = new Set();\n    const solutionPath = solve(maze, userPosition[0], userPosition[1]);\n    solutionPath.forEach((path) => {\n      const [x, y] = path;\n      s.add(String(x) + \"-\" + String(y));\n    });\n    return s;\n  }, [size, userPosition[0], userPosition[1], gameId]);\n\n  useEffect(() => {\n    const lastRowIndex = maze.length - 1;\n    const lastColIndex = maze[0].length - 1;\n    if (userPosition[0] === lastRowIndex && userPosition[1] === lastColIndex) {\n      setStatus(\"won\");\n    }\n  }, [userPosition[0], userPosition[1]]);\n\n  const makeClassName = (i, j) => {\n    const rows = maze.length;\n    const cols = maze[0].length;\n    let arr = [];\n    if (maze[i][j][0] === 0) {\n      arr.push(\"topWall\");\n    }\n    if (maze[i][j][1] === 0) {\n      arr.push(\"rightWall\");\n    }\n    if (maze[i][j][2] === 0) {\n      arr.push(\"bottomWall\");\n    }\n    if (maze[i][j][3] === 0) {\n      arr.push(\"leftWall\");\n    }\n    if (i === rows - 1 && j === cols - 1) {\n      arr.push(\"destination\");\n    }\n    if (i === userPosition[0] && j === userPosition[1]) {\n      arr.push(\"currentPosition\");\n    }\n\n    if (cheatMode && solution.has(String(i) + \"-\" + String(j))) {\n      arr.push(\"sol\");\n    }\n    return arr.join(\" \");\n  };\n\n  const handleMove = (e) => {\n    e.preventDefault();\n    if (status !== \"playing\") {\n      return;\n    }\n    const key = e.code;\n\n    const [i, j] = userPosition;\n    if ((key === \"ArrowUp\" || key === \"KeyW\") && maze[i][j][0] === 1) {\n      setUserPosition([i - 1, j]);\n    }\n    if ((key === \"ArrowRight\" || key === \"KeyD\") && maze[i][j][1] === 1) {\n      setUserPosition([i, j + 1]);\n    }\n    if ((key === \"ArrowDown\" || key === \"KeyS\") && maze[i][j][2] === 1) {\n      setUserPosition([i + 1, j]);\n    }\n    if ((key === \"ArrowLeft\" || key === \"KeyA\") && maze[i][j][3] === 1) {\n      setUserPosition([i, j - 1]);\n    }\n  };\n\n  const handleUpdateSettings = () => {\n    setSize(Number(document.querySelector(\"input[name='mazeSize']\").value));\n    setUserPosition([0, 0]);\n    setStatus(\"playing\");\n    setGameId(gameId + 1);\n  };\n\n  return (\n    <div className=\"App\" onKeyDown={handleMove} tabIndex={-1}>\n      <div className=\"setting\">\n        <label htmlFor=\"mazeSize\">Size of maze (5-40):</label>\n        <input\n          type=\"number\"\n          name=\"mazeSize\"\n          min=\"5\"\n          max=\"40\"\n          defaultValue=\"10\"\n        />\n      </div>\n      <div className=\"setting\">\n        <button onClick={handleUpdateSettings}>\n          Restart game with new settings\n        </button>\n      </div>\n      <p>use WSAD or Arrow Keys to move</p>\n      <div>\n        <label htmlFor=\"cheatMode\">Cheat mode</label>\n        <input\n          type=\"checkbox\"\n          name=\"cheatMode\"\n          onChange={(e) => setCheatMode(e.target.checked)}\n        />\n      </div>\n\n      <table id=\"maze\">\n        <tbody>\n          {maze.map((row, i) => (\n            <tr key={`row-${i}`}>\n              {row.map((cell, j) => (\n                <td key={`cell-${i}-${j}`} className={makeClassName(i, j)}>\n                  <div />\n                </td>\n              ))}\n            </tr>\n          ))}\n        </tbody>\n      </table>\n\n      {status !== \"playing\" && (\n        <div className=\"info\" onClick={handleUpdateSettings}>\n          <p>you won (click here to play again)</p>\n        </div>\n      )}\n    </div>\n  );\n}\n","import { StrictMode } from \"react\";\nimport ReactDOM from \"react-dom\";\n\nimport App from \"./App\";\n\nconst rootElement = document.getElementById(\"root\");\nReactDOM.render(\n  <StrictMode>\n    <App />\n  </StrictMode>,\n  rootElement\n);\n"],"sourceRoot":""}